---
title: "2_env_pred_processing_future"
format: html
---

```{r}
# clear the environment
rm(list = ls())
```

## Overview/Purpose

This script processes all of the future climate variables from the BCM that we'll use as environmental predictor variables to transfer our species distribution models (SDMs). We'll be processing the following data:

- `aet`: actual evapotranspiration
- `cwd`: climatic water deficit
- `ppt`: precipitation

For each climate variable, we have data for:

- two 30-year averaged time periods (`2020-2049`, `2040-2069`) 
- four GCMs (`CanESM2`, `CNRM-CM5`, `HadGEM2-ES`, `MIROC5`)
- two emission scenarios (`RCP45`, `RCP85`)

The resulting processed raster files will be saved in the `data/intermediate/misc/env_predictors/bcm_gcm_ensemble/` directory. There will be 12 files produced, one for each combination of climate variable, time period, and emission scenario averaged across all three GCMs.

## Setup

#### Load packages

```{r}
# load required packages
library(terra)
library(here)
library(tidyverse)
library(tigris)
library(sf)
library(tmap)
```

#### Load the template raster to match crs, extent, and resolution

```{r}
# processed aet historic raster
ref_raster <- rast(here("data/intermediate/misc/habitat_suitability/env_predictors/baseline/aet1991_2020_ave_CA_270m.tif"))
```

#### Define future BCM data file paths & parameters

```{r}
# BCM future data path
input_dir <- here("data/raw/bcm/bcmv8_future/")
output_dir <- here("data/intermediate/misc/habitat_suitability/env_predictors/future/bcm_gcm_ensemble/")

# define parameters
climate_vars <- c("aet", "cwd", "ppt")
gcms <- c("CanESM2", "CNRM-CM5", "HadGEM2-ES", "MIROC5")
scenarios <- c("RCP45", "RCP85")
time_periods <- c("2020_2049", "2040_2069")
```

## Create functions for data processing

#### Function to create file path

```{r}
# file path function to get the .asc file path for a given: 
# variable, gcm, scenario, and period

get_asc_path <- function(input_dir, var, gcm, scenario, period) {
  # construct folder name: var_GCM_scenario_30yr
  folder_name <- paste0(var, "_", gcm, "_", scenario, "_30yr")
  
  # construct file name: var_period_ave.asc
  file_name <- paste0(var, "_", period, "_ave.asc")
  
  # full path
  file_path <- file.path(input_dir, folder_name, file_name)
  
  return(file_path)
}
```

#### Function to average rasters across GCMs

```{r}
# average rasters across GCMs for a given variable, scenario, and period

average_across_gcms <- function(input_dir, var, gcms, scenario, period) {
  # collect rasters from all GCMs
  raster_list <- list()
  
  for (i in seq_along(gcms)) {
    gcm <- gcms[i]
    file_path <- get_asc_path(input_dir, var, gcm, scenario, period)
    
    # check if file exists
    if (!file.exists(file_path)) {
      warning("File not found: ", file_path)
      next
    }
    
    # read the raster
    message("  Reading: ", basename(file_path), " from ", gcm)
    r <- rast(file_path)
    
    # set CRS - BCM data uses California Albers (EPSG:3310)
    crs(r) <- "EPSG:3310"
    
    # replace -9999 with NA
    message("    Converting -9999 to NA...")
    r[r == -9999] <- NA
    
    raster_list[[i]] <- r
  }
  
  # check if we have any rasters to average
  if (length(raster_list) == 0) {
    stop("No rasters found for ", var, " ", scenario, " ", period)
  }
  
  # stack all rasters and calculate mean
  raster_stack <- rast(raster_list)
  ensemble_mean <- mean(raster_stack, na.rm = TRUE)
  
  return(ensemble_mean)
}
```

#### Function to fill NAs with 3x3 focal mean

```{r}
# function to fill NA values with mean of neighboring cells (3x3 moving window)
fill_all_na <- function(raster, max_iter = 100) {
  r <- raster
  for (i in 1:max_iter) {
    if (!any(is.na(values(r)))) break
    r <- focal(r,
               w = 3,                # 3x3 moving window
               fun = mean,
               na.rm = TRUE,         # ignore NAs in calculation
               na.policy = "only")   # only replace NA cells, leave others as is
  }
  return(r)
}
```

#### Function to align raster to match processed historic raster

```{r}
# reproject and resample to match reference raster

align_to_reference <- function(input_raster, ref_raster, method = "mean") {
 
  # step 1: reproject to match reference CRS if needed
  if (!same.crs(input_raster, ref_raster)) {
    message("    Reprojecting to match reference CRS...")
    input_raster <- project(input_raster, crs(ref_raster))
  }
  
  # step 2: resample to match reference resolution and extent
  # this also effectively clips to the reference extent
  message("    Resampling to match reference resolution and extent...")
  aligned_raster <- resample(input_raster, ref_raster, method = method)
  
  # Step 3: sask to reference raster (use NA values from reference as mask)
  message("    Masking to reference raster...")
  aligned_raster <- mask(aligned_raster, ref_raster)
  
  return(aligned_raster)
}
```

## Process data: loop through variables, scenarios, and periods

```{r}
# track output files
output_files <- character()

# process each combination of variable, scenario, and time period
for (var in climate_vars) {
  for (scenario in scenarios) {
    for (period in time_periods) {
      
      message("\nProcessing: ", toupper(var), " | ", scenario, " | ", period)
      message(paste(rep("-", 50), collapse = ""))
      
      # calculate ensemble mean across GCMs
      ensemble_raster <- average_across_gcms(
        input_dir = input_dir,
        var = var,
        gcms = gcms,
        scenario = scenario,
        period = period
      )
      
      # align to reference raster (reproject, resample, clip, mask)
      message("  Aligning to reference raster...")
      ensemble_raster <- align_to_reference(
        input_raster = ensemble_raster,
        ref_raster = ref_raster,
        method = "mean" 
      )
      
      
      # fill remaining NAs with 3x3 moving window mean
      message("  Filling NAs with 3x3 moving window mean...")
      na_count_before <- sum(is.na(values(ensemble_raster)))
      message("    NAs before filling: ", na_count_before)
      
      ensemble_raster <- fill_all_na(ensemble_raster, max_iter = 100)
      
      na_count_after <- sum(is.na(values(ensemble_raster)))
      message("    NAs after filling: ", na_count_after)
      message("    NAs filled: ", na_count_before - na_count_after)
      
      
      # crop to ref raster to remove edge effects
      message("  Cropping to reference raster extent to remove edge effects...")
      ensemble_raster <- ensemble_raster %>% 
        crop(ref_raster) %>% 
        mask(ref_raster)
      
      
      # re-align again to reference
      message("  Re-aligning to reference raster after filling NAs...")
      ensemble_raster <- align_to_reference(
        input_raster = ensemble_raster,
        ref_raster = ref_raster,
        method = "mean"
      )
      
      # check final NA count
      final_na_count <- sum(is.na(values(ensemble_raster)))
      message("    Final NAs after re-alignment: ", final_na_count)
      
      
      # construct output filename
      # format: var_scenario_period_gcm_ensemble.tif
      output_name <- paste0(var, "_", scenario, "_", period, "_gcm_ensemble.tif")
      output_path <- file.path(output_dir, output_name)
      
      # save as GeoTIFF
      writeRaster(
        ensemble_raster,
        filename = output_path,
        overwrite = TRUE
      )
      
      message("  Saved: ", output_name)
      
      # get summary statistics
      message("  Summary statistics:")
      raster_summary <- summary(values(ensemble_raster))
      print(raster_summary)
      message("")
      
      output_files <- c(output_files, output_path)
    }
  }
}
```

#### Project to WGS84 (`EPSG:4326`) for use in Wallace

```{r}
# define output directory for WGS84 files
wgs_output_dir <- file.path(output_dir, "WGS84")

# track WGS84 output files
wgs_output_files <- character()

# reproject each ensemble file to WGS84
for (f in output_files) {
  message("Reprojecting: ", basename(f))
  
  # load the raster
  r <- rast(f)
  
  # reproject to WGS84
  r_wgs <- project(r, "EPSG:4326", method = "mean")
  
  # construct output filename (add _wgs84 suffix)
  original_name <- tools::file_path_sans_ext(basename(f))
  wgs_output_name <- paste0(original_name, "_wgs84.tif")
  wgs_output_path <- file.path(wgs_output_dir, wgs_output_name)
  
  # save as GeoTIFF
  writeRaster(
    r_wgs,
    filename = wgs_output_path,
    overwrite = TRUE
  )
  
  message("  Saved: ", wgs_output_name)
  wgs_output_files <- c(wgs_output_files, wgs_output_path)
}
```

## Plot some of the projections

#### Load the SJV vector boundary for plotting

```{r}
# load SJV boundary for masking
sjv_boundary <- read_sf(here("data/raw/sjv_counties/sjv_counties.shp"))

# transform SJV boundary to EPSG:3310
sjv_boundary <- st_transform(sjv_boundary, crs = crs(ref_raster))
crs(sjv_boundary)
# convert to terra vector
sjv_vect <- vect(sjv_boundary)
```

#### Load the projections as raster stacks & crop to SJV

```{r}
# RCP45 (2020-2049) ensemble mean for each variable 
rcp45_2020_2049_path <- list.files(output_dir, 
                                   pattern = "RCP45_2020_2049.*\\.tif$",
                                   full.names = TRUE)
rcp45_2020_2049_stack <- rast(rcp45_2020_2049_path)

# RCP45 (2040-2069) ensemble mean for each variable
rcp45_2040_2069_path <- list.files(output_dir,
                                   pattern = "RCP45_2040_2069.*\\.tif$",
                                   full.names = TRUE)
rcp45_2040_2069_stack <- rast(rcp45_2040_2069_path)

# RCP85 (2020-2049) ensemble mean for each variable
rcp85_2020_2049_path <- list.files(output_dir,
                                   pattern = "RCP85_2020_2049.*\\.tif$",
                                   full.names = TRUE)
rcp85_2020_2049_stack <- rast(rcp85_2020_2049_path)

# RCP85 (2040-2069) ensemble mean for each variable
rcp85_2040_2069_path <- list.files(output_dir,
                                   pattern = "RCP85_2040_2069.*\\.tif$",
                                   full.names = TRUE)
rcp85_2040_2069_stack <- rast(rcp85_2040_2069_path)


# crop to SJV extent
rcp45_2020_2049_stack_sjv <- rcp45_2020_2049_stack %>% 
  crop(sjv_vect) %>% 
  mask(sjv_vect)
rcp45_2040_2069_stack_sjv <- rcp45_2040_2069_stack %>% 
  crop(sjv_vect) %>% 
  mask(sjv_vect)
rcp85_2020_2049_stack_sjv <- rcp85_2020_2049_stack %>% 
  crop(sjv_vect) %>% 
  mask(sjv_vect)
rcp85_2040_2069_stack_sjv <- rcp85_2040_2069_stack %>% 
  crop(sjv_vect) %>% 
  mask(sjv_vect)
```

#### Plot the projections

```{r}
# convert terra vectors to sf for easier handling
sjv_sf <- st_as_sf(sjv_vect)

## Create expanded bounding box for SJV
sjv_bbox <- st_bbox(sjv_sf)
sjv_buffer <- 0.1
x_expand <- sjv_buffer * (unname(sjv_bbox["xmax"]) - unname(sjv_bbox["xmin"]))
y_expand <- sjv_buffer * (unname(sjv_bbox["ymax"]) - unname(sjv_bbox["ymin"]))

sjv_bbox_expanded <- st_bbox(c(
  xmin = unname(sjv_bbox["xmin"]) - x_expand,
  xmax = unname(sjv_bbox["xmax"]) + x_expand,
  ymin = unname(sjv_bbox["ymin"]) - y_expand,
  ymax = unname(sjv_bbox["ymax"]) + y_expand
), crs = st_crs(sjv_sf))
```

```{r}
# stack the RCP45 and RCP85 stacks together for plotting and name them
rcp45_stack <- c(rcp45_2020_2049_stack_sjv, rcp45_2040_2069_stack_sjv)
names(rcp45_stack) <- c("AET RCP45 (2020_2049)", "CWD RCP45 (2020_2049)",
                        "PPT RCP45 (2020_2049)", "AET RCP45 (2040_2069)",
                        "CWD RCP45 (2040_2069)", "PPT RCP45 (2040_2069)")

rcp85_stack <- c(rcp85_2020_2049_stack_sjv, rcp85_2040_2069_stack_sjv)
names(rcp85_stack) <- c("AET RCP85 (2020_2049)", "CWD RCP85 (2020_2049)",
                        "PPT RCP85 (2020_2049)", "AET RCP85 (2040_2069)",
                        "CWD RCP85 (2040_2069)", "PPT RCP85 (2040_2069)")

# plot the stacks using tmap
tm_shape(rcp45_stack, bbox = sjv_bbox_expanded) +
  tm_raster(col.scale = tm_scale_continuous(values = "viridis"), 
            col.legend = tm_legend(title = "mm / yr", 
                                   position = tm_pos_in("left", "bottom"))) +
  tm_layout(panel.labels = names(rcp45_stack), 
            panel.label.size = 0.8) +
  tm_facets(ncol = 3)
```

#### Find the difference between RCP45 projections for each variable and time period

Interpretation:
- Positive values indicate an increase in `mm/yr` from the earlier period (2020-2049) to the later period (2040-2069).
- Negative values indicate a decrease in `mm/yr` from the earlier period to the later period.

```{r}
# calculate difference between RCP45 projections for each variable and time period
aet_diff_rcp45_2020_2049 <- rcp45_stack[[4]] - rcp45_stack[[1]]
cwd_diff_rcp45_2020_2049 <- rcp45_stack[[5]] - rcp45_stack[[2]]
ppt_diff_rcp45_2020_2049 <- rcp45_stack[[6]] - rcp45_stack[[3]]

# plot the differences
rcp45_diff_stack <- c(aet_diff_rcp45_2020_2049, cwd_diff_rcp45_2020_2049, 
                      ppt_diff_rcp45_2020_2049)
names(rcp45_diff_stack) <- c("AET Δ (2040-2069 - 2020-2049)", 
                             "CWD Δ (2040-2069 - 2020-2049)", 
                             "PPT Δ (2040-2069 - 2020-2049)")

tm_shape(rcp45_diff_stack, bbox = sjv_bbox_expanded) +
  tm_raster(col.scale = tm_scale_continuous(values = "RdBu"), 
            col.legend = tm_legend(title = "mm / yr", 
                                   position = tm_pos_in("left", "bottom"))) +
  tm_layout(panel.labels = names(rcp45_diff_stack), 
            panel.label.size = 0.8) +
  tm_facets(ncol = 3)
```











