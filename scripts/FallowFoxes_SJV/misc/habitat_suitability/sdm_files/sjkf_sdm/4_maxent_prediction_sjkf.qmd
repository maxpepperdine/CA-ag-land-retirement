---
title: "SJKF MaxEnt prediction generation"
author: "Stella Wing"
format: html
editor: visual
date: last-modified
editor_options: 
  chunk_output_type: console
---

## Overview

This script reads in the prepared SJKF occurrence records (produced in `1_extract_occ_env_data_sjkf.qmd`) and background points (produced in `2_generate_bg_points_sjkf.qmd` and `3_extract_bg_env_data_sjkf.qmd`) to evaluate and generate MaxEnt models using the `dismo` package.

```{r}
#rm(list = ls())
```

## Load packages

```{r}
library(tidyverse)  # always
library(dismo)      # for MaxEnt
library(terra)      # for raster data
library(corrplot)   # for plotting correlation matrix
library(ENMeval)    # for model evaluation
library(rJava)      # needed for MaxEnt predictions
library(sf)         # for spatial data
library(tmap)       # for plotting better maps
library(here)       # for file paths
library(kableExtra) # for nice tables
```

## Bind the occurrence and background data into one df

#### Load data

```{r}
# load occurrence data with env data extracted
occ_data <- read_csv(here("data/sjkf_occ_env_data.csv"))

# load background data with env data extracted
bg_data <- read_csv(here("data/sjkf_bg_env_data.csv"))
```

```{r}
# env pred raster for reprojecting
env_raster <- rast(here("data/baseline/sjkf/aet1991_2020_ave_CA_270m.tif"))
```

```{r}
# CA lakes shapefile for masking the final prediction rasters
ca_lakes <- read_sf(here("data/California_Lakes/California_Lakes.shp")) %>% 
  st_transform(crs(env_raster))
```

#### Prepare data for Maxent

Add a column indicating presence (1) or absence/background (0), and bind the two datasets together.

```{r}
# add presence column to occ data
occ_data_bind <- occ_data %>%
  mutate(presence = 1, 
         .after = 2)

# add presence column to bg data
bg_data_bind <- bg_data %>%
  mutate(presence = 0, 
         .after = 2)

# bind the two datasets together
full_data <- rbind(occ_data_bind, bg_data_bind)
```

```{r}
## Test 

library(terra)

# Select precipitation raster
r <- env_rasters[["ppt1991_2020_ave"]]

# Convert to SpatVector
full_vect <- vect(full_data,
                  geom = c("longitude", "latitude"),  # change if needed
                  crs = "EPSG:4326")

# Reproject to match raster
full_vect <- project(full_vect, crs(r))


par(mfrow = c(1,1))
par(mar = c(2,2,2,2))

plot(r,
     main = "Occurrences (red) and Background (blue)")

# Background points (presence = 0)
points(full_vect[full_vect$presence == 0, ],
       pch = 16,
       col = "blue",
       cex = 0.4)

# Occurrence points (presence = 1)
points(full_vect[full_vect$presence == 1, ],
       pch = 16,
       col = "red",
       cex = 0.6)

```

## Model evaluation

#### Test for correlation

Assessing the correlation between environmental variables for MaxEnt. A Pearson correlation matrix is produced; based on the values, certain variables may be removed from the final SWD file.

```{r}
# select only the environmental variables
env_data_corr <- full_data %>%
  dplyr::select(4:14)

# create a correlation matrix
cor_matrix <- cor(env_data_corr, # binded occ & bg data with only env variables
                  method = "pearson", # Pearson correlation method
                  use = "complete.obs") # use complete observations only

# plot the correlation matrix with corrplot ******* REVIEW HERE
cor_plot <- corrplot::corrplot(cor_matrix,
                               method = "color", # color method
                               type = "upper", # upper triangle
                               tl.col = "black", # text label color
                               tl.srt = 45, # text label rotation
                               addCoef.col = "black", # add correlation coefficients
                               number.cex = 0.7) # number size
```

#### Model evaluation

Using the `ENMevaluate()` function from the `ENMeval` package, we can evaluate the model performance using different feature classes and regularization multipliers. Spatial partitioning with the `block` partition method is used to evaluate model performance.

After selecting the best model, we can use the `maxent()` function from the `dismo` package to run the model with the selected feature class and regularization multiplier. In this step, we'll use the `jacknife` partition argument to assess the importance of each environmental variable in the model.

```{r}
# remove unwanted variables from occ & bg data
occ_data <- occ_data %>%
  dplyr::select(-c(sand_pct_0_10cm, silt_pct_0_10cm, 
                   tmn1991_2020_ave, tmx1991_2020_ave))
bg_data <- bg_data %>%
  dplyr::select(-c(sand_pct_0_10cm, silt_pct_0_10cm, 
                   tmn1991_2020_ave, tmx1991_2020_ave))

# set up the block for spatial partitioning
block <- ENMeval::get.block(occ_data, bg_data, 
                            orientation = "lat_lon")
# check for even distribution of blocks
table(block$occs.grp)


## Evaluating the model
max.eval.sjkf <- ENMeval::ENMevaluate(occs = occ_data, 
                                      bg = bg_data, 
                                      tune.args = list(fc = c("L", "LQ", "P"), 
                                                      rm = seq(0.5, 3, 0.5)),
                                      algorithm = "maxnet", 
                                      partitions = "block")
```

```{r}
# examine the model results
max.eval.sjkf
eval.results(max.eval.sjkf) # model evaluation results
eval.tune.settings(max.eval.sjkf) # extract the tuning parameter settings 
eval.results.partitions(max.eval.sjkf) # assess model performance for each partition

# clean results
results <- eval.results(max.eval.sjkf) %>%
  dplyr::select(fc, rm, auc.train, auc.val.avg, AICc, delta.AICc, 
                or.10p.avg, or.mtp.avg, cbi.val.avg) %>% 
  arrange(AICc) %>% 
  mutate(across(where(is.numeric), \(x) round(x, digits = 3)))

# make a nice table
library(kableExtra)

kable(results, row.names = FALSE) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
                full_width = FALSE) %>%
  row_spec(1, bold = TRUE)  # highlight the top model


# plot stat results across values of the tuning parameters
evalplot.stats(e = max.eval.sjkf, 
               # or.mtp me
               stats = c("or.mtp", "auc.val"), 
               facet.labels = c("or.mtp" = "OR (mtp)", 
                                "auc.val" = "AUC (val)"),
               x.var = "rm", 
               color = "fc", 
               error.bars = FALSE)

# removing delta.AICc for plotting because it gets included with AIC by default
max.eval.filtered <- max.eval.sjkf
max.eval.filtered@results <- max.eval.sjkf@results[, !colnames(max.eval.sjkf@results) %in% "delta.AICc"]

evalplot.stats(e = max.eval.filtered,
               stats = c("AICc", "auc.train"),
               facet.labels = c("AICc" = "AIC", 
                                "auc.train" = "AUC (train)"), 
               x.var = "rm",
               color = "fc",
               error.bars = FALSE)


#==============================================================================
# Best model: fc.LQ_rm.1 ####### REVIEW
#==============================================================================


# save the evaluation results to avoid re-running the model
save(max.eval.sjkf, 
     file = here("data/max_eval_sjkf.rda"))

# load the evaluation results
load(here("data/max_eval_sjkf.rda"))
```

## Running MaxEnt & generating predictions

After identifying the best model based on the evaluation results, we'll run the model using the `dismo::maxent()` function. This generates a model object that can be used to predict baseline (historical) and future SJKF occurrence probability under projected environmental data using the `dismo::predict()` function.

#### Run MaxEnt with the selected model

This section generates a MaxEnt model using the selected feature class and regularization multiplier from the evaluation results above that produced the highest performing models (`fc.LQ_rm.0.5`).

These model objects are then used to predict baseline (historical) and future SJKF occurrence probabilities.

#### Baseline (fc LQ and rm 1)

```{r}
## set up model parameters based on the evaluation results

x <- full_data %>% 
  na.omit() %>%
  # select only the environmental variables
  dplyr::select(4:14) %>% 
  dplyr::select(-c(sand_pct_0_10cm, silt_pct_0_10cm, 
                   tmn1991_2020_ave, tmx1991_2020_ave)) 

# # examine how many presence and absence points were lost from NA removal
# x_summary <- x %>%
#   group_by(presence) %>%
#   summarize(n = n())

# occurrence & background data 
# if using a df for `x` maxent() requires a vector of 0's and 1's for presence 
# and absence that equal nrow(x)
p <- full_data %>% 
  na.omit() %>%
  pull(presence) # turn p into a vector of 0's and 1's for presence and absence

args <- c("jackknife=TRUE",      # assess variable importance
          "linear=TRUE",         # use linear features
          "quadratic=TRUE",      # use quadratic features
          "hinge=FALSE",         # do not use hinge features
          "product=FALSE",       # do not use product features
          "threshold=FALSE",     # do not use threshold features
          "responsecurves=TRUE", # generate response curves
          "writeplotdata=TRUE",  # write output data used to make response curves 
          "betamultiplier=0.5")  # this is the rm coefficient from ENMevaluate()


# path to save results
path <- here("data/4_maxent_predictions/")


## final model run
maxent_sjkf <- maxent(x = x, 
                      p = p, 
                      args = args, 
                      path = path)

# save model object for prediction rasters
save(maxent_sjkf, 
     file = here("data/4_maxent_predictions/maxent_prediction_sjkf_sdm.rda"))
```

#### Predict baseline (historical) SJKF occurrence probability

```{r}
#### set up the prediction parameters

## load the model object
load(here("data/4_maxent_predictions/maxent_prediction_sjkf_sdm.rda"))


## load the environmental data as a raster stack 

# define the path to the predictor variable rasters
env_path <- here("data/baseline/sjkf")
env_files <- list.files(env_path, 
                        pattern = ".tif$", 
                        full.names = TRUE)

# get a raster stack of the land cover files
x_stack <- raster::stack(env_files)
# check the layer names; need to match pred var names in SWD data
names(x_stack)
# match the layer names to the predictor variable names in the SWD data
names(x_stack) <- c("aet1991_2020_ave", "clay_pct_0_10cm", "cwd1991_2020_ave", 
                        "ec_dS_m_0_10cm", "pH_0_10cm", "ppt1991_2020_ave", 
                        "sand_pct_0_10cm", "silt_pct_0_10cm", "slope", 
                        "tmn1991_2020_ave", "tmx1991_2020_ave")

# get rid of cwd layer since it was not used in the model
#layers_to_drop <- c("cwd1991_2020_ave") ### REVIEW 

#x_stack <- dropLayer(x_stack, layers_to_drop)

# make sure the raster stack is in EPSG:3310
x_stack <- projectRaster(x_stack, crs = crs(env_raster))
crs(x_stack)
plot(x_stack)



## define the extent as the extent from the Stewart SDM

# load the Stewart BNLL extent shapefile
stewart_bnll_ext_path <- here("data/ca_state/ca_state_boundary_no_islands.shp") # try with SJV counties shp file, 

stewart_bnll_ext <- read_sf(stewart_bnll_ext_path) %>% 
  sf::st_make_valid() # make sure the geometry is valid

# assign the correct CRS
stewart_bnll_ext <- st_transform(stewart_bnll_ext, crs(x_stack))

# extent object required for dismo
stewart_bnll_ext <- extent(stewart_bnll_ext)


## define the filename path for the prediction raster
filename_sjkf <- here::here("data/4_maxent_predictions/maxent_sjkf_pred_fillNAs.tif")


## predict current HEC 
dismo::predict(object = maxent_sjkf, 
               x = x_stack, 
               ext = stewart_bnll_ext,
               filename = filename_sjkf, 
               overwrite = TRUE) 

## plot the prediction raster!!
par(mar = c(5, 5, 4, 6))  # bottom, left, top, right
pred_rast_sjkf <- rast(filename_sjkf)
plot(pred_rast_sjkf, 
     main = "MaxEnt Predicted Habitat Suitability 
     for San Joaquin Kit Fox (Vulpes macrotis)")

pred_rast_sjkf <- rast(filename_sjkf)
plot(pred_rast_sjkf)

```

```{r}
# Meeting plot 

library(terra)

# Load SJV shapefile
sjv <- vect(here("data/sjv_counties/sjv_counties.shp"))

# Match CRS
sjv <- project(sjv, crs(pred_rast_sjkf))

# Crop + mask
pred_clip <- mask(crop(pred_rast_sjkf, sjv), sjv)

# Get extent
e <- ext(pred_clip)

# Manually expand extent (20% buffer)
x_range <- e[2] - e[1]
y_range <- e[4] - e[3]

zoom_ext <- ext(e[1] - 0.2 * x_range,
                e[2] + 0.2 * x_range,
                e[3] - 0.2 * y_range,
                e[4] + 0.2 * y_range)

par(mfrow = c(1,1))
par(mar = c(2,2,3,2))

# IMPORTANT: use xlim + ylim (not ext=)
plot(pred_clip,
     xlim = c(zoom_ext[1], zoom_ext[2]),
     ylim = c(zoom_ext[3], zoom_ext[4]),
     main = "MaxEnt Predicted Habitat Suitability\nClipped to San Joaquin Valley")

lines(sjv, col = "black", lwd = 1.5)

```

#### Mask lakes from prediction raster

```{r}
ca_lakes <- st_zm(ca_lakes, drop = TRUE, what = "ZM") # review what is Z dimention in multipolygon? 

# convert lakes sf object to SpatVector
ca_lakes_vect <- vect(ca_lakes)

# rasterize the lakes
ca_lakes_rast <- rasterize(ca_lakes_vect, 
                           pred_rast_sjkf, 
                           field = 1)
plot(ca_lakes_rast)

# mask the lakes from the prediction raster; set lake pixels to 0
sjkf_habitat_masked <- pred_rast_sjkf
sjkf_habitat_masked[ca_lakes_rast] <- 0

plot(sjkf_habitat_masked, 
     main = "SJKF baseline habitat suitability prediction")

# save the masked raster
writeRaster(sjkf_habitat_masked,
            here("data/maxent_sjkf_pred_masked_lakes.tif"),
            overwrite = TRUE)
```

## Predict future SJKF occurrence probability under projected environmental data

Transfer the model to future environmental data under `RCP4.5` and `RCP8.5` for two time periods (`2020-2049` and `2040-2069`) to predict future SJKF occurrence probability under projected environmental conditions.

Produce 4 future prediction rasters for each RCP and time period combination.

```{r}
# ==============================================================================
# Set up some prediction parameters:
# ==============================================================================

## load the best performing model object trained with the baseline data
load(here("data/4_maxent_predictions/maxent_prediction_sjkf_sdm.rda"))


## define the extent as the extent from the Stewart SDM
# load the Stewart BNLL extent shapefile
stewart_bnll_ext_path <- here("data/stewart_sdm_ext/stewart_sdm_ext.shp")


stewart_bnll_ext <- read_sf(stewart_bnll_ext_path) %>% 
  sf::st_make_valid() # make sure the geometry is valid

# assign the correct CRS
#stewart_bnll_ext <- st_transform(stewart_bnll_ext, crs(x_fut_stack)) # come back to x_fut_stack

# extent object required for dismo
stewart_bnll_ext <- extent(stewart_bnll_ext)
```

#### RCP45 -- 2020-2049

```{r}
#### set up the prediction parameters

## load the environmental data as a raster stack
env_fut_folder <- here("data/future/sjkf/rcp45_2020_2049")

# define the path to the predictor variable rasters for RCP4.5 and 2020-2049
env_fut_files <- list.files(path = env_fut_folder, 
                            pattern = ".tif$", 
                            full.names = TRUE)

# get a raster stack of the future predictor variable files
x_fut_stack <- raster::stack(env_fut_files)
# check the layer names; need to match pred var names in SWD data
names(x_fut_stack)

# match the layer names to the predictor variable names in the SWD data
names(x_fut_stack) <- c("aet1991_2020_ave", "clay_pct_0_10cm", 
                        "cwd1991_2020_ave", "ec_dS_m_0_10cm", "pH_0_10cm", 
                        "ppt1991_2020_ave", "slope", "tmn1991_2020_ave", 
                        "tmx1991_2020_ave")

# get rid of tmn and tmx 
layers_to_drop <- c("tmn1991_2020_ave", "tmx1991_2020_ave")
x_fut_stack <- dropLayer(x_fut_stack, layers_to_drop)

# make sure the raster stack is in EPSG:3310
x_fut_stack <- projectRaster(x_fut_stack, crs = crs(env_raster))
crs(x_fut_stack)
plot(x_fut_stack)


## define the filename path for the future prediction raster
filename_sjkf_rcp45_2020_2049 <- here::here("data/4_maxent_predictions/maxent_sjkf_pred_rcp45_2020_2049.tif")

## predict future HEC under RCP4.5 and 2020-2049
dismo::predict(object = maxent_sjkf,
               x = x_fut_stack,
               ext = stewart_bnll_ext,
               filename = filename_sjkf_rcp45_2020_2049,
               overwrite = TRUE)

## mask lakes from the future prediction raster

# load the future prediction raster
pred_rast_sjkf_rcp45_2020_2049 <- rast(filename_sjkf_rcp45_2020_2049)

# set lake pixels to 0
sjkf_habitat_masked_rcp45_2020_2049 <- pred_rast_sjkf_rcp45_2020_2049
sjkf_habitat_masked_rcp45_2020_2049[ca_lakes_rast] <- 0

plot(gkr_habitat_masked_rcp45_2020_2049, 
     main = "GKR habitat suitability; RCP4.5 (2020-2049)")


# save the masked future prediction raster
writeRaster(sjkf_habitat_masked_rcp45_2020_2049, 
            here("data/4_maxent_predictions_sjkf/maxent_sjkf_pred_rcp45_2020_2049_masked_lakes.tif"),
            overwrite = TRUE)
```
